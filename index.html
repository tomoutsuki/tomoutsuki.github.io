<<<<<<< HEAD
<!DOCTYPE html>
<html lang="ja-JP"></html>

<head>
    <meta charset="utf-8">
    <title>Keyaki｜Artist Page</title>
    <link rel="icon" type="image/png" href="/favicon16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/favicon32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/favicon96x96.png" sizes="96x96"> 
    
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.4/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="reset.css">
    <link rel="stylesheet" href="index.css">
    <link rel="stylesheet" href="soundwave.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    <link href="https://fonts.googleapis.com/css2?family=Klee+One&family=Noto+Sans+JP&family=Noto+Serif+JP&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet">

    <!--<script src="menubar.js"></script>-->
    <script src="https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.min.js"></script>
    <script src="soundwave.js" type="module"></script>
    <script src="share.js" type="module"></script>
    <script src="love.js" type="module"></script>
</head>

<body>
    <header class="pc-header pc-only">
        <a href="#">
            <img class="logo" src="Assets/logo.svg" alt="logo"/>
        </a>
        <ul class="nav-list">
            <li class="nav-list-item">
                <a href="profile.html">Profile</a>
            </li>
            <li class="nav-list-item">
                <a href="#">Portfolio</a>
            </li>
            <li class="nav-list-item">
                <a href="#">Social</a>
            </li>
            <li class="nav-list-item">
                <a href="#">Contact</a>
            </li>
        </ul>
    </header>

    <header class="mobile-header mobile-only">
        <a href="#">
            <img class="logo" src="Assets/logo.svg" alt="logo"/>
        </a>
        <a href="javascript:void(0);" class="menubar" onclick="switchMenu()">
            <img src="assets/menu-icon.svg"/>
        </a>
    </header>

    <header id="mobile-header-menu" class="fadeUp-noDelay">
            <a href="profile.html">Profile</a>
            <a href="#">Portfolio</a>
            <a href="#">Social</a>
            <a href="#">Contact</a>
    </header>

    <main id="main-content">
        <section class="banner fadeUp-instant">
            <div class="banner-content">
                <div class="banner-quote">
                    <img class="double-quotation" src="Assets/Icons/quote.png" />
                    <h1>The journey above the genres.</h1>
                </div>
                <div class="waveform-container">
                    <div id="waveform">
                        <div id="time">0:00</div>
                        <div id="duration">0:00</div>
                        <div id="hover"></div>
                    </div>
                    <a id="play-pause">
                        <img id="play-button" src="Assets/Icons/play.svg">
                        <img id="pause-button" src="Assets/Icons/play.svg">
                    </a>
                </div>
                <img class="cover" src="Assets/cover.png" />
                <div class="music-info-container">
                    <h2>Abgrundkrieg</h2>
                    <h3>Artcore, Deep Ocean</h3>
                    <div class="music-link">
                        <div class="music-social-media">
                            <a href="" target="_blank"><img class="music-icon" src="Assets/Icons/youtube.svg" /></a>
                            <a href="" target="_blank"><img class="music-icon" src="Assets/Icons/spotify.svg" /></a>
                            <a href="" target="_blank"><img class="music-icon" src="Assets/Icons/soundcloud.svg" /></a>
                        </div>
                        <div class="music-reaction">
                            <span id="heart-number"></span>
                            <div class="heart-button">
                                <img id="heart-icon" src="Assets/Icons/heart.svg" />
                                <img id="red-heart-icon" class="wiggle" src="Assets/Icons/heart_red.svg" />
                            </div>
                            <div class="share-button">
                                <img class="music-icon" src="Assets/Icons/share.svg" />
                            </div>
                        </div>
                        
                    </div>
                </div>
            </div>
        </section>

        <section class="dream">
            <div class="dream-content">
                
            </div>
        </section>

        <section class="atelier">
            <div class="atelier-title">
                <h1>Atelier</h1>
                <p>I always give to my works life to orchestrate not just melodies, but also captivating visuals. I harmonize both worlds, creating my own arts to complement and elevate my music productions. With a pen in one hand, mouse in other, midi keyboard, guitar... I paint and play.</p>
            </div>

            <div class="atelier-carousel">
                <div id="myCarousel" class="carousel slide" data-ride="carousel">
                    <!-- Indicators -->
                    <ol class="carousel-indicators">
                    <li data-target="#myCarousel" data-slide-to="0" class="active"></li>
                    <li data-target="#myCarousel" data-slide-to="1"></li>
                    <li data-target="#myCarousel" data-slide-to="2"></li>
                    </ol>
                
                    <!-- Wrapper for slides -->
                    <div class="carousel-inner">
                    <div class="item active">
                        <img src="Assets/hopeoncyber.png" alt="hopeoncyber.png">
                        <div class="carousel-caption">
                        <h3>Hope on Cyber</h3>
                        <p>Why not to have some cyberpunkish life?</p>
                        </div>
                    </div>
                
                    <div class="item">
                        <img src="Assets/memory.png" alt="Geography">
                        <div class="carousel-caption">
                        <h3>Nevertheless Friend</h3>
                        <p>Past days, Nowadays memories.</p>
                        </div>
                    </div>
                
                    <div class="item">
                        <img src="Assets/homeland.png" alt="Homeland">
                        <div class="carousel-caption">
                        <h3>Homeland</h3>
                        <p>Nature is where Art set roots deep.</p>
                        </div>
                    </div>
                    </div>
                
                    <!-- Left and right controls -->
                    <a class="left carousel-control" href="#myCarousel" data-slide="prev">
                    <span class="glyphicon glyphicon-chevron-left"></span>
                    <span class="sr-only">Previous</span>
                    </a>
                    <a class="right carousel-control" href="#myCarousel" data-slide="next">
                    <span class="glyphicon glyphicon-chevron-right"></span>
                    <span class="sr-only">Next</span>
                    </a>
                </div>
            </div>
        </section>
    </main>

    <section id="share-screen">
        <!-- AddToAny BEGIN -->
        <div>
            <a href="https://www.addtoany.com/share#url=https%3A%2F%2Fkeyaki.me%2F&amp;title=" target="_blank"><img src="https://static.addtoany.com/buttons/a2a.svg" width="32" height="32" style="background-color:royalblue"></a>
            <a href="https://www.addtoany.com/add_to/facebook?linkurl=https%3A%2F%2Fkeyaki.me%2F&amp;linkname=" target="_blank"><img src="https://static.addtoany.com/buttons/facebook.svg" width="32" height="32" style="background-color:royalblue"></a>
            <a href="https://www.addtoany.com/add_to/twitter?linkurl=https%3A%2F%2Fkeyaki.me%2F&amp;linkname=" target="_blank"><img src="https://static.addtoany.com/buttons/twitter.svg" width="32" height="32" style="background-color:royalblue"></a>
            <a href="https://www.addtoany.com/add_to/whatsapp?linkurl=https%3A%2F%2Fkeyaki.me%2F&amp;linkname=" target="_blank"><img src="https://static.addtoany.com/buttons/whatsapp.svg" width="32" height="32" style="background-color:royalblue"></a>
            <a href="https://www.addtoany.com/add_to/email?linkurl=https%3A%2F%2Fkeyaki.me%2F&amp;linkname=" target="_blank"><img src="https://static.addtoany.com/buttons/email.svg" width="32" height="32" style="background-color:royalblue"></a>
            </div>
            <!-- AddToAny END -->
    </section>

    <footer>
        <div class="footer-menu">
            <div class="footer-column footer-column-1">
                <h3>Portfolio</h3>
                <a href="#">Music</a>
                <a href="#">Atelier</a>
            </div>
            <div class="footer-column footer-column-2">
                <h3>Profile</h3>
                <a href="#">About me</a>
                <a href="#">Services</a>
                <a href="#">Hobbies Life</a>
            </div>
            <div class="footer-column footer-column-3">
                <h3>Services</h3>
                <a href="#">Shop</a>
                <a href="#">Events</a>
                <a href="#">Contact</a>
            </div>
        </div>
        <div class="school-info">
            <div class="sns pc-only">
                <!--<a href="#"><img src="assets/instagram.svg"/></a>
                <a href="#"><img src="assets/facebook.svg"/></a>
                <a href="#"><img src="assets/twitter.svg"/></a>-->
            </div> 
            <hr class="mobile-only">
            <img class="logo footer-logo" src="Assets/logo.svg"/>
            <div class="school-info-text">
                <p>TEL +55(00)00000-0000</p>
                <p>Email: outsuki.tom@gmail.com</p>
                <a class="contact-button" href="#">Contact</a>
                <a class="contact-button" href="#">Curriculum</a>
            </div>
            <div class="sns mobile-only">
                <!--<a href="#"><img src="assets/instagram.svg"/></a>
                <a href="#"><img src="assets/facebook.svg"/></a>
                <a href="#"><img src="assets/twitter.svg"/></a>-->
            </div> 
        </div>
    </footer>

    <div class="copyright">
        © 2023 Keyaki Project
    </div>

</body>
</html>
=======
<html
 <head>
  <title>Keyaki</title>
 </head>
 <body>
  
Arquitetura de Sistem

Sistemas Operacionais



Parte 2 – Processos, Threads e Escalonamento.



Revisão do Conteúdo Prova 2






Sistemas Operacionais



Parte 2 – Processos, Threads e Escalonamento.





Arquitetura de Sistem

Processos




Arquitetura de Sistem

Sumário
Bloco de Controle do Processo

Swapping

Processos independentes, subprocessos e

threads

Processos foreground e background

Processos do sistema operacional

Processos CPU-bound e I/O-bound

Sinais





Arquitetura de Sistem

Bloco de Controle do Processo
PCB (Process Control Block)

Estrutura de dados que implementa o processo.



Mantém as informações sobre o contexto de hardware, software e espaço de endereçamento do processo.



Os PCBs de todos os processos ativos residem na memória principal em uma área exclusiva do SO.





Arquitetura de Sistem

Bloco de Controle do Processo
PCB (Process Control Block)





ponteiros

Estado do processo

Nome do processo

Prioridade do processo



Registradores

Limites de memória

Lista de arquivos abertos

.

.

.

.





Arquitetura de Sistem

Bloco de Controle do Processo
PCB (Process Control Block)











Arquitetura de Sistem

Bloco de Controle do Processo
PCB (Process Control Block)

é representado no sistema operacional Linux pela estrutura em C “task_struct”.



É encontrada no arquivo de inclusão

<linux/sched.h> no diretório de código-fonte

do kernel.



Essa estrutura contém as informações, como: estado do processo, informações de scheduling e de gerenciamento da memória, a lista de arquivos abertos, ponteiros para o pai do processo e uma lista de seus filhos e irmãos.





Arquitetura de Sistem

Bloco de Controle do Processo
PCB (Process Control Block)



Exemplo:



Dentro do kernel do Linux, todos os processos ativos são representados com o uso de uma lista duplamente encadeada de task_struct. O kernel mantém um ponteiro (current) para o processo em execução corrente no sistema.





Arquitetura de Sistem

Bloco de Controle do Processo
PCB (Process Control Block)







Fundamentos de Sistemas Operacionais, 9ed

Abraham Silberschatz



Arquitetura de Sistem

Mudanças de Estado do Processo
Um processo em estado de pronto ou de espera pode não se encontrar na memória principal.



Esta condição ocorre quando não existe espaço suficiente para todos os processos na memória principal e parte do contexto do processo é levado para memória secundária.



Técnica de Swapping:

Swap out – retira os processos da memória principal.


Swap in – Traz os processos de volta para a memória principal.




Mudanças de Estado
Mudanças de estado do processo (2)



Estado de Execução







residente

não residente

Arquitetura de Sistem

Estado de Espera







Estado de Espera

Estado de Pronto







Estado de Pronto





Arquitetura de Sistem

Processos CPU e I/O Bound
CPU-bound (ligado à UCP):

É quando um processo passa a maior parte do tempo no estado de execução, utilizando a UCP ou no estado de pronto.



Esse tipo de processo realiza poucas operações de leitura e gravação, e é encontrado em aplicações científicas que efetuam muitos cálculos.





Arquitetura de Sistem

Processos CPU e I/O Bound
I/O-bound (ligado à E/S):

É quando um processo passa a maior parte do tempo no estado de espera, pois realiza um elevado número de operações de E/S.



Esse tipo de processo é encontrado em aplicações comerciais, que se baseiam em leitura, processamento e gravação.



Processos interativos são exemplos de processos I/O-bound.





Processos CPU e I/O Bound
Processos CPU x I/O Bound



Arquitetura de Sistem

E/ S E/ S



UCP UCP





CPU-bound

tempo tempo

I/ O-bound







Arquitetura de Sistem

Processos Foreground e Background
Processos Foreground:

É aquele que permite a comunicação direta do usuário com o processo durante o seu processamento.



Neste caso, tanto o canal de entrada quanto o de saída estão associados a um terminal com teclado, mouse e monitor, permitindo, assim, a interação com o usuário.





Arquitetura de Sistem

Processos Foreground e Background
Processos Background:

É aquele onde não existe a comunicação com o usuário durante o seu processamento.



Neste caso, os canais de E/S não estão associados a nenhum dispositivo de E/S interativo, mas em geral a arquivos de E/S.



O processamento do tipo batch é realizado através de processos background.





Processos Foreground e Background




Processo Foreground





Arquitetura de Sistem




terminal

entrada

saída






terminal





Processo Background





arquivo de entrada

entrada

saída



arquivo de saída





Arquitetura de Sistem

Processos Foreground e Background











Arquitetura de Sistem

Processo Foreground e Background
Pipe










entrada do Processo A

saída do Processo A





Processo A





Processo B



entrada do Processo B





saída do Processo B





Arquitetura de Sistem

Processos Independentes, Subprocessos e
Threads
São maneiras diferentes de implementar a concorrência dentro de uma aplicação.



Busca-se subdividir o código em partes para trabalharem de forma cooperativa.





Arquitetura de Sistem

Processos Independentes, Subprocessos e
Threads
Processos independentes:


É a maneira mais simples de implementar a

concorrência em sistemas multiprogramáveis.



Não existe vínculo do processo criado com o seu

criador.



Exige a alocação de um PCB, possuindo contextos de hardware, contextos de software e espaços de endereçamento próprios.





Arquitetura de Sistem

Processos Independentes, Subprocessos e
Threads


Subprocessos:


São processos criados dentro de uma estrutura

hierárquica.



O processo criador é denominado processo-pai, enquanto o novo processo é chamado de subprocesso ou processo-filho.



Relação de dependência entre o processo criador e

o subprocesso.



O processo-pai cede parte de suas quotas.





Arquitetura de Sistem

Processos Independentes, Subprocessos e
Threads
Processo A

Processo B

Processo C

Processo D

Processo E











Arquitetura de Sistem

Processos Independentes, Subprocessos e
Threads
Chamadas de sistemas para criação.



Unix utiliza Fork-Exec.



Windows utiliza CreateProcess.







Uso de sinais

Sinais
Notificar processos de eventos gerados pelo sistema operacional ou por outros processos.



Maior parte gerado pelo SO ou pelo hardware (exceções, interrupções, limites de cotas e alarmes de tempo).



Arquitetura de Sistem



[ctrl-C]

interrupção



sinal







Sistema Operacional

Processo





Arquitetura de Sistem

Sistemas Operacionais



Parte 2 – Processos e Threads



Threads






Arquitetura de Sistem

Sumário
Ambiente monothread

Ambiente multithread

Arquitetura e implementação





Arquitetura de Sistem

Ambiente Monothread
Neste tipo de ambiente, um processo suporta apenas um programa no seu espaço de endereçamento.



As aplicações concorrentes são implementadas apenas com o uso de múltiplos processos independentes ou subprocessos.



Permite dividir a aplicação em partes que podem

trabalhar de forma concorrente.



Cada funcionalidade do software implicaria na criação de um novo processo  aumentando o desempenho.







Arquitetura de Sistem

Ambiente Monothread
Concorrência com processos









Subprocessos ProcessosIndependentes





Arquitetura de Sistem

Ambiente Monothread
Qual é o problema neste tipo de implementação?





Arquitetura de Sistem

Ambiente Monothread
Qual é o problema neste tipo de implementação?



O uso de processos no desenvolvimento de aplicações concorrentes demanda consumo de diversos recursos do sistema.



Novo processo  Alocação de recursos  tempo UCP



Término processo  Gasto de tempo  desalocar

recursos.





Arquitetura de Sistem

Ambiente Monothread
Qual é o problema neste tipo de implementação?



O uso de processos no desenvolvimento de aplicações concorrentes demanda consumo de diversos recursos do sistema.



Cada processo possui seu próprio espaço de endereçamento  comunicação lenta e difícil.



Pipes, sinais ou troca de mensagens.





Arquitetura de Sistem

Ambiente Monothread
Ambiente monothread







Thread



Thread



Thread









Arquitetura de Sistem

Ambiente Multithread
Com múltiplos threads, não existe a ideia de programas associados a processos, mas, sim, a threads.



O processo tem pelo menos um thread de execução, mas pode compartilhar seu espaçamento com outros inúmeros threads.





Arquitetura de Sistem

Ambiente Multithread
Ambiente multithread





Contexto de hardware



Contexto de hardware



Contexto de hardware















































































































Contexto de software

Thread 1

Thread 2

Thread 3



Espaço de endereçamento



Arquitetura de Sistem

Ambiente Multithread
Ambiente monothread x Ambiente Multithread










Arquitetura de Sistem

Ambiente Multithread
Um thread pode ser definido como uma sub-rotina de um programa que pode ser executada de forma assíncrona.



Possibilita a execução concorrente de sub-rotinas dentro de um mesmo processo.







Ambiente Multithread
Arquitetura de Sistem

Processo



...

Espaço de endereçamento



Programa Principal



Call Sub_1 Call Sub_2



Fim

Variáveis

Contexto de Hardware

Thread_1



PC SP



Sub_1



Ret

Contexto de Hardware

Thread_2



PC SP



...

Contexto de Hardware

Thread_3



Sub_2



Ret

PC SP





1 – Processo

1 – Thread

Espaço de endereçamento



Variáveis



Ambiente Multithread
Contexto de Contexto de

Hardware Hardware

Thread_2



PC SP



Thread_3 PC

SP

...

...

Contexto de Hardware

Thread_1



Programa Principal



Call Sub_1 Call Sub_2



Fim

PC SP



Sub_1



Ret



Sub_2



Ret







Arquitetura de Sistem



Arquitetura de Sistem

Ambiente Multithread




Pilha










1 – Processo

3 – Threads

Espaço de endereçamento



Variáveis



Programa Principal



Call Sub_1 Call Sub_2



Fim



Sub_1



Ret



Ambiente Multithread
...

Thread_1



PC SP



Contexto de Hardware

Contexto de Hardware

Thread_2



PC SP



...

Contexto de Hardware

Thread_3



Sub_2



Ret

PC SP







Arquitetura de Sistem



Arquitetura de Sistem

Ambiente Multithread


Pilha 3

Pilha 2

Pilha 1









Arquitetura de Sistem

Ambiente Multithread










Arquitetura de Sistem

Ambiente Multithread
Neste ambiente, cada processo pode responder a várias solicitações de forma concorrente ou mesmo simultânea  mais de uma UCP.



Vantagem: minimizar a alocação de recursos do sistema e diminuir o overhead (sobrecarga) na criação, troca e eliminação de processos.




Arquitetura de Sistem

Ambiente Multithread
Threads compartilham a UCP da mesma maneira que processos e passam pelas mesmas mudanças de estado.



Para permitir a troca de contexto entre diversos threads cada um possui seu próprio contexto de Hardware.





Arquitetura de Sistem

Ambiente Multithread
Quando um thread está em execução  contexto de Hardware  registradores UCP.



No momento em que perde a utilização da UCP registradores UCP  Contexto de Hardware.



Threads compartilham o mesmo contexto de software e espaço de endereçamento com os demais threads.





Arquitetura de Sistem

Ambiente Multithread
As threads são implementadas pela estrutura de dados denominada bloco de controle de thread.



Thread Control Block – TCB



Além do contexto de hardware, o TCB armazena a prioridade, estado de execução e bits de estado.



Informações relacionadas ao thread.







Arquitetura de Sistem

Ambiente Multithread













Arquitetura de Sistem

Ambiente Multithread
Em ambientes monothread, o processo é ao mesmo tempo a unidade de alocação de recursos e a unidade de escalonamento.



A independência entre os conceitos de processo e thread permite separar a unidade de alocação de recursos da unidade de escalonamento.



Unidade de alocação de recursos é o processo onde todos os seus threads compartilham o espaço de endereçamento.







Arquitetura de Sistem

Ambiente Multithread
Cada thread representa uma unidade de escalonamento independente. O sistema não seleciona um processo para a execução, mas sim um de seus threads.



Processos independentes e subprocessos possuem espaços de endereçamento individuais e protegidos.



Threads compartilham o espaço dentro de um mesmo processo.



Compartilhamento de dados simples e rápido.



Arquitetura de Sistem

Ambiente Multithread
Não existe qualquer proteção no acesso à memória.



É fundamental que a aplicação implemente mecanismos de comunicação e sincronização entre threads.



A utilização da UCP, discos e outros periféricos  threads  melhor utilização dos recursos computacionais.





Arquitetura de Sistem

Ambiente Multithread
Exemplo: Tarefas em background e operações de E/S.



Aplicações como editores de texto, planilhas, aplicativos gráficos e processadores de imagens.



São especialmente beneficiadas quando desenvolvidas com base em threads.





53

Arquitetura de Sistem








Arquitetura de Sistem

Ambiente Multithread
Exemplo 2 : Ambientes cliente-servidor.



Threads são essenciais para solicitações de

serviços remotos.



No ambiente monothread  aplicação solicita um serviço remoto  ela pode ficar esperando  resultado.



Um thread pode solicitar o serviço remoto, enquanto a aplicação pode continuar realizando outras atividades.

55

Arquitetura de Sistem








Arquitetura de Sistem

Programação Multithread
O desenvolvimento não é simples:



Exige comunicação e o compartilhamento de recursos de forma sincronizada para evitar inconsistências.



Procedimento de depuração é complexo.



Número total de threads e a forma como são criados e eliminados.



Número excessivo de threads  overhead.



Arquitetura de Sistem

Arquitetura e Implementação


Threads em modo usuário.



Threads em modo kernel.



Threads em modo híbrido.



Arquitetura de Sistem

Threads em Modo Usuário
São implementados pela aplicação e não pelo sistema operacional.



Biblioteca de rotinas que possibilite à aplicação realizar tarefas como criação/eliminação de threads, troca de mensagens entre threads e uma política de escalonamento.



O SO não sabe da existência de múltiplos threads.



Arquitetura de Sistem

Threads em Modo Usuário
Vantagem: possibilidade de implementar aplicações multithreads mesmo em sistemas operacionais que não suportam threads.


São rápidos e eficientes, pois evitam a mudança do modo de acesso (usuário-kernel-usuário).



Arquitetura e Implementação
Threads em modo usuário



Arquitetura de Sistem





Thread 0



Thread 1



Thread 2



Thread 3



Thread 4

Biblioteca

Kernel

Modo usuário





Modo kernel



Arquitetura de Sistem

Arquitetura e Implementação
Threads em modo usuário








Arquitetura de Sistem

Threads em Modo Usuário
Limitação: sistema operacional gerencia cada processo como se existisse apenas um único thread.


Problema: tratamento individual de sinais  devem ser reconhecidos e encaminhados  threads



Arquitetura de Sistem

Threads em Modo Usuário
Não é possível que múltiplos threads de um processo possam ser executados em diferentes UCPs ao mesmo tempo.



O sistema seleciona apenas “processos” e não threads.



Esta restrição limita drasticamente o grau de paralelismo da aplicação.



Arquitetura de Sistem

Threads em Modo Kernel
São implementados diretamente pelo núcleo do SO.



Através de chamadas as rotinas do sistema que oferecem todas as funções de gerenciamento e sincronização.



O SO sabe da existência de cada thread e pode escaloná-los individualmente.



Em sistemas com vários UCPs  podem ter execução simultânea.



Arquitetura e Implementação
Threads em modo kernel



Kernel

Arquitetura de Sistem

Thread 0

Thread 1

Thread 2

Thread 3

Thread 4

Modo usuário



Modo kernel



Arquitetura de Sistem

Arquitetura e Implementação
Threads em modo kernel







Arquitetura de Sistem

Threads em Modo Kernel
Problema: Baixo desempenho. Utilizam chamadas a rotinas do sistema  várias mudanças no modo de acesso.

TMU X TMK
68

Arquitetura de Sistem









Arquitetura de Sistem

Threads em Modo Híbrido
Combina as vantagens de threads implementados em modo usuário (TMU) e modo kernel (TMK).



Um processo pode ter vários TMKs e, por sua vez, um TMK pode ter vários TMUs.



O núcleo do sistema reconhece os TMKs e pode escaloná-los individualmente.







Arquitetura de Sistem

Threads em Modo Híbrido
O programador desenvolve a aplicação em termos de TMUs e especifica quantos TMKs estão associados ao processo.



Apesar da maior flexibilidade, apresenta problemas herdados de ambas as implementações.





Arquitetura e Implementação
Threads em modo híbrido.





Kernel



TMK 3



TMK 2



TMK 1



TMK 0



Biblioteca

Arquitetura de Sistem

TMU 0

TMU 1

TMU 2

TMU 3

TMU 4

TMU 5

Modo usuário



Modo kernel





Arquitetura de Sistem

Threads em Modo Híbrido
Apesar da maior flexibilidade, apresenta problemas herdados de ambas as implementações:



Quando um TMK realiza uma chamada bloqueante, todos os TMUs são colocados no estado de espera.







Arquitetura de Sistem

Sistemas Operacionais



Parte 2 – Processos e Threads



Escalonamento e Gerência do Processador









Funções Básicas

Sumário
Critérios de escalonamento

Escalonamentos não-preemptivos e preemptivos

Escalonamento FIFO

Escalonamento SJF

Escalonamento Cooperativo

Escalonamento Circular (Round Robin)

Escalonamento Por Prioridades



Arquitetura de Sistem



Arquitetura de Sistem

Sumário
Escalonamento Circular Com Prioridades

Escalonamento Por Múltiplas Filas

Política de Escalonamento em Sistemas de

Tempo Compartilhado

Política de Escalonamento em Sistemas de Tempo Real





Arquitetura de Sistem

Introdução
Estado de Execução

Estado de Espera

Estado de Pronto










Escalonamento

Os critérios utilizados para esta seleção compõem a chamada política de escalonamento, que é a base da gerência do processador e da multiprogramação em um sistema operacional.







Arquitetura de Sistem

Funções Básicas
Manter a UCP ocupada a maior parte do tempo



Balancear o uso da UCP entre processos



Privilegiar a execução de aplicações críticas



Maximizar o throughput (processos executados em um intervalo de tempo)



Oferecer tempos de resposta razoáveis para usuários

interativos







Arquitetura de Sistem

Funções Básicas
A política de escalonamento é implementada por 2 rotinas principais:



O Escalonador (Scheduler), implementa os critérios da política de escalonamento e determina o próximo processo a entrar em execução.



O Dispatcher realiza a troca de contexto dos processos conforme definido pelo scheduler. O tempo gasto para troca dos processos é conhecido como Latência do Dispatcher.





Arquitetura de Sistem

Funções Básicas
A política de escalonamento é implementada por 2 rotinas principais:



Observação: SOs que implementam threads, tratam os processos como unidades de alocação de recursos, e as threads como unidades de escalonamento.





Arquitetura de Sistem

Critérios de Escalonamento
As características de cada SO determinam quais são os principais aspectos para a implementação de uma política de escalonamento adequada.



Sistemas de tempo compartilhado  exigem que o escalonamento trate todos os processos de forma igual  evitando o starvation.



Sistemas de tempo real  o escalonamento deve priorizar a execução de processos críticos em detrimento da execução de outros processos.





Arquitetura de Sistem

Critérios de Escalonamento
Utilização do Processador: Processador deve permanecer ocupado maior parte do tempo.



Throughput: Representa o número de processos executados em função do tempo. (processos / intervalo de tempo)  Sua maximização é desejada na maioria dos sistemas.



Tempo de Processador ou Tempo de CPU: De todo o tempo necessário para executar o processo, é o tempo em que ele ficou efetivamente em estado de execução. Depende apenas do código da aplicação e da entrada de dados.







Arquitetura de Sistem

Critérios de Escalonamento
Tempo de Espera: tempo total que um processo permanece na fila de pronto durante seu processamento, aguardando para ser executado.



Tempo de Turnaround: Tempo total de execução, da criação ao encerramento. Leva em conta o tempo de espera, tempo de CPU e na fila de espera (operações de E/S).



Tempo de Resposta: Tempo entre requisição (tecla digitada) e resposta (exibição no monitor). Crítico em sistemas on-line (rede, web).





Arquitetura de Sistem

Critérios de Escalonamento
De maneira geral, qualquer política de escalonamento busca:



Otimizar a utilização do processador e o throughput.



Diminuir os tempos de turnaround, espera e

resposta.



Dependendo do tipo de SO, um critério pode ter maior importância do que outros, como nos sistemas interativos, onde o tempo de resposta tem grande relevância.







Arquitetura de Sistem

Tipos de Escalonamento
Políticas de Escalonamento podem ser classificadas conforme a possibilidade do SO interromper um processo em execução e substituí-lo por outro (Preempção):



Escalonamento não-preemptivo:

Primeiro tipo de escalonamento implementado (para

processamento batch).



Quando um processo está em execução nenhum evento

externo pode ocasionar a perda do uso do processador.



Processo só sai do estado de execução ao fim do processamento ou por mudança para estado de espera.





Arquitetura de Sistem

Tipos de Escalonamento
Políticas de Escalonamento podem ser classificadas conforme a possibilidade do SO interromper um processo em execução e substituí-lo por outro (Preempção):



Escalonamento preemptivo:

O SO pode interromper um processo em execução e passá-lo para o estado de pronto, com o objetivo de alocar outro processo na UCP.

Permite uso de prioridades (Tempo Real, por exemplo).

Permite compartilhamento uniforme (balanceamento).

Mais flexível, é o tipo de escalonamento usado atualmente pela maioria dos SOs.





Arquitetura de Sistem

Escalonamento FIFO
FIFO (First-In-First-Out) ou FCFS Scheduling (First-Come-First-Served)  processo que chega primeiro ao estado de pronto é o primeiro a ser executado.



Bastante simples, controlado por uma fila de processos em estado Pronto: processo que passa para Pronto entra no final da fila, e é escalonado quando chega ao início da fila.



Quando o processo entra em estado de espera, o processo no início da fila é escalonado. Ao final da espera, processo volta ao final da fila de pronto.





Arquitetura de Sistem

Escalonamento FIFO
Escalonamento First-In-First-Out





Estado de Criação

Fila dos processos no estado de Pronto

UCP

Estado de Espera



Estado de Término













Exemplo



Processo A



Processo B



Processo C



Tempo Médio de Espera: (0+10+14)/3= 8

Arquitetura de Sistem

Tempo Médio de Turnaround: (10+14+17)/3= 13,7









Processo A

10 14 17

u.t.





Processo

Tempo de processador (u.t.)

A

10

B

4

C

3

Processo B



Processo C



Tempo Médio de Espera: (7+0+4)/3= 3,7 Tempo Médio de Turnaround: (17+4+7)/3= 9,3



4 7 17 u.t.



Arquitetura de Sistem

Escalonamento FIFO
Apesar de possuir implementação simples, apresenta alguns problemas:



Não se preocupa em melhorar tempo médio de espera, utilizando apenas a ordem de chegada na fila.



Piora Turnaround de processos que precisariam de

pouco tempo de CPU.



Processos CPU-Bound levam vantagem sobre processos I/O-Bound. Se houver I/O-Bound mais importante, não haverá prioridade.





Arquitetura de Sistem

Escalonamento FIFO











Arquitetura de Sistem

Escalonamento FIFO
O escalonamento FIFO é do tipo não preemptivo e foi inicialmente implementado em sistemas com processamento batch.



É ineficiente se aplicado em sua forma original. Atualmente, é utilizado com variações.





Arquitetura de Sistem

Escalonamento SJF
Escalonamento shortest-job-first (SJF scheduling), também conhecido como shortest-process-next (SPN scheduling).



O algoritmo de escalonamento seleciona o processo que tiver o menor tempo de processador ainda por executar.



Desta forma, o processo em estado de pronto que necessitar de menos tempo de UCP para terminar seu processamento é selecionado para execução.





Escalonamento SJF
Exemplo: Processos A, B e C com tempos de processador 10, 4 e 3 u.t. (unidades de tempo) e mesmo instante de criação.



Arquitetura de Sistem

Processo A



Processo B



Processo C



3 7 17 u.t.

Tempo Médio de Espera: (7+3+0)/3= 3,3 Tempo Médio de Turnaround: (17+7+3)/3= 9



Arquitetura de Sistem

Escalonamento SJF
Tempo médio de espera diminui, pois processos mais rápidos são executados primeiro.



Para cada novo processo é associado um tempo de processador ao seu contexto de software. Como não é possível precisar o tempo de processador previamente, o mesmo era estimado com base em análise de execuções passadas dos programas.



Caso tempo estimado fosse muito inferior ao real,

processo era interrompido





Arquitetura de Sistem

Escalonamento SJF
Problema: impossibilidade de estimar o tempo para processos interativos.



Na sua concepção inicial, o SJF é um escalonamento não preemptivo.



Reduz tempo médio de turnaround, porém pode haver starvation para processos com tempo muito longo ou CPU-Bound.



Variação: SJF com Preempção (SRT Scheduling-Shortest Remaining Time)  Se há um processo em pronto com tempo estimado menor que o processo em execução, são trocados.



Arquitetura de Sistem

Escalonamento Cooperativo
Busca o aumento do grau de multiprogramação em sistemas não-preemptivos.



Processo em execução pode voluntariamente liberar o processador, retornando à fila de pronto  possibilita que um novo processo seja escalonado  melhor distribuição do uso da UCP.



A liberação do processador, portanto, é feita pelo processo em execução, que fica verificando se há outros na fila de pronto, se houver, o processo cooperativamente libera a CPU.





Arquitetura de Sistem

Escalonamento Cooperativo
Podem ocorrer problemas pela falta de controle do SO: se um processo não verificar a fila, os demais não terão chance de ser executados até a liberação da UCP pelo processo em execução.



Problema: um programa pode permanecer por um longo período de tempo alocando o processador.



Era utilizado nas primeiras versões do Windows, com o nome de Multitarefa Cooperativa.





Arquitetura de Sistem

Escalonamento Circular
Round Robin Scheduling  Projetado para sistemas de tempo compartilhado. Método Preemptivo.



Semelhante ao FIFO, com a diferença de que utiliza time-slice (fatia de tempo) ou quantum.



Quando processo entra em execução, recebe um tempo limite para uso contínuo do processador. Quando tempo se esgota, processo é interrompido pelo SO, seu contexto é salvo e o processo volta para a fila de pronto (preempção por tempo).





Arquitetura de Sistem

Escalonamento Circular




Estado de Criação

Fila dos processos no estado de Pronto

UCP

Preempção por tempo

Estado de Espera



Estado de Término















Escalonamento Circular
Exemplo - Fatia de Tempo = 2 u.t.



Arquitetura de Sistem

Processo A





Processo B



Processo C

Processo A = 10 u.t. Processo B = 4 u.t.

Processo C = 3 u.t.



2 4 6 8 10 11

17 u.t.





Arquitetura de Sistem

Escalonamento Circular
O valor da fatia de tempo depende do SO, mas geralmente varia de 10 a 100 milissegundos.



Este valor afeta diretamente o desempenho: valor muito alto provoca tendência do Round Robin funcionar como o FIFO, valor muito baixo gera muitas preempções, o que faz com que a latência do dispatcher afete o tempo de turnaround.



Vantagem: não permite que um processo monopolize a UCP, o que é adequado para sistemas de tempo compartilhado.





Arquitetura de Sistem

Escalonamento Circular
Problema da política: CPU-Bound são beneficiados em detrimento dos I/O-Bound, pois CPU-Bound aproveitam toda a fatia de tempo, e I/O-Bound geralmente passam para o estado de espera antes da preempção por tempo.



Estas características distintas ocasionam um balanceamento desigual no uso do processador entre os processos.







Arquitetura de Sistem

Escalonamento Circular
Escalonamento circular virtual

– Processos na fila auxiliar têm prioridade aos processos na fila de pronto.





Estado de Criação

Fila dos processos no estado de Pronto

UCP

Preempção por tempo

Fila auxiliar

Estado de Espera



Estado de Término



















Arquitetura de Sistem

Escalonamento por Prioridades
É um escalonamento do tipo preemptivo.



Baseado em um valor de prioridade (denominado prioridade de execução) associado a cada processo.



Processo com maior prioridade na fila de pronto é escolhido para execução. Processos com valores iguais são escalonados por FIFO.



Não há fatia de tempo, portanto, não há preempção por tempo.





Arquitetura de Sistem

Escalonamento por Prioridades
A perda do processador ocorre por mudança para estado de espera ou quando um processo de maior prioridade passa para o estado de pronto (preempção por prioridade).



É implementado por interrupção de clock, que faz com que de tempos em tempos o escalonador avalie as prioridades dos processos em estado de pronto.



Para cada prioridade existe uma fila de prontos, tratada como uma fila circular. Execução começa pela fila com prioridade mais alta.





Escalonamento por Prioridades


Filas dos processos no estado de Pronto



Prioridade P1



Prioridade P2

Estado de Criação

UCP

Prioridade Pn

Preempção por prioridade

Estado de Espera





















Arquitetura de Sistem

Estado de Término









Escalonamento por Prioridades
Exemplo com processos de prioridade diferentes (A-2, B-1, C-3), onde 5 é o valor de prioridade mais alta.



Arquitetura de Sistem



Processo

Tempo de processador (u.t.)



Prioridade

A

10

2

B

4

1

C

3

3

Processo A



Processo B



Processo C



3 13 17 u.t.





Arquitetura de Sistem

Escalonamento por Prioridades
Cada SO implementa sua faixa de valores para as prioridades de execução. Alguns associam valores altos às maiores prioridades, outros associam valores baixos.



Prioridade faz parte do contexto de software do processo, e pode ser:



Estática: valor não muda durante a existência do processo.



Dinâmica: valor pode ser alterado durante execução, permitindo ajustar o critério de escalonamento em função do comportamento do processo.





Arquitetura de Sistem

Escalonamento por Prioridades
Problema da política: Possibilidade de Starvation para processos de baixa prioridade.



Solução: com prioridade dinâmica pode haver Aging, que incrementa a prioridade do processo conforme seu tempo na fila de prontos.



Política de escalonamento por prioridades é bastante útil em sistemas de tempo real, e também em sistemas de tempo compartilhado, em que, às vezes, é necessário priorizar o escalonamento de determinados processos.







Arquitetura de Sistem

Escalonamento Circular com Prioridades
Implementa o conceito de fatia de tempo e de prioridade de execução associada a cada processo.



Neste tipo de escalonamento, um processo permanece no estado de execução até que:



Termine seu processamento;

Voluntariamente passe para o estado de espera;

Sofra uma preempção por tempo ou prioridade.







Arquitetura de Sistem

Escalonamento Circular com Prioridades


Fila dos processos no estado de Pronto



Prioridade P1

Prioridade P2

Estado de Criação

UCP

Prioridade Pn

Preempção por tempo ou prioridade

Estado de Espera



Estado de Término

























Arquitetura de Sistem

Escalonamento Circular com Prioridades
A principal vantagem deste escalonamento é permitir o melhor balanceamento no uso do processador em sistemas de tempo compartilhado.



Processos com o perfil I/O-bound devem receber do administrador do sistema prioridades com valores maiores que as dos processos CPU-bound.



Isso permite ao sistema operacional praticar uma política compensatória entre processos de perfis distintos, compartilhando o processador de forma mais igualitária.







Arquitetura de Sistem

Escalonamento Circular com Prioridades
O escalonamento circular apresenta duas variações:



Prioridades estáticas: a prioridade definida no contexto de software de cada processo permanece inalterada ao longo de sua existência.



Prioridades dinâmicas: é possível que a prioridade de um processo seja alterada dinamicamente pelo administrador do sistema ou, em algumas políticas, pelo próprio sistema operacional.







Escalonamento por Múltiplas Filas
Exemplo: processo de sistema, interativos ou batch. Fila de processos de sistema pode implementar escalonamento baseado em prioridades, enquanto as outras filas utilizam escalonamento circular.












Arquitetura de Sistem

Fila de processos do sistema

UCP



Maior prioridade



Fila de processos interativos

























Fila de processos batch

Menor prioridade







Arquitetura de Sistem

Políticas em Sistemas de Tempo Compartilhado
Caracterizam-se pelo processamento interativo, no qual usuários interagem com as aplicações exigindo tempos de respostas baixos.



A escolha de uma política de escalonamento para atingir este propósito deve levar em consideração o compartilhamento dos recursos de forma equitativa para possibilitar o uso balanceado da UCP entre processos.





Arquitetura de Sistem

Políticas em Sistemas de Tempo Compartilhado
Sistemas com prioridade dinâmica são mais complexos, porém o aumento de eficiência compensa. A maioria dos sistemas atuais de tempo compartilhado utiliza essa política de escalonamento.







Arquitetura de Sistem

Políticas em Sistemas de Tempo Real
Em Sistemas de Tempo Compartilhado, as aplicações não são comprometidas pela variação do tempo de resposta.



Para aplicações que exigem resposta imediata, devem ser utilizados Sistemas de Tempo Real, que garantem a execução de processos dentro de limites rígidos de tempo.



Exemplos: Aplicações de controle de processos, como sistemas de controle de produção de bens industriais e controle de tráfego aéreo.







Arquitetura de Sistem

Políticas em Sistemas de Tempo Real
Para esse tipo de sistema, o escalonamento por prioridades é o mais adequado, com cada processo recebendo uma prioridade de acordo com sua importância dentro da aplicação.



Não há fatia de tempo e a prioridade deve ser estática.

.





Sistemas Operacionais



Parte 2 – Processos, Threads e Escalonamento





Arquitetura de Sistem

Sincronização de Processos




Arquitetura de Sistem

Sumário
Definição de concorrência

Implementação de concorrência

Problemas de Compartilhamento

Exclusão Mútua

Soluções de Hardware

Soluções de Software

Sincronização Condicional

Semáforos

Monitores

Deadlocks


 </body>
</html>
>>>>>>> 344dfce71192739e59f8c4a12f4b400cca08d418
